// ********************************************************
// * Copyright 2006 Regents of the University of California. 
// * All rights reserved.
// *
// * Project Director: Prof. Chenming Hu.
// * Authors: Chung-Hsun Lin, Mohan Dunga, Darsen Lu, 
// *          Ali Niknejad, Chenming Hu
// ********************************************************

// ********************************************************
// *   NONDISCLOSURE STATEMENT
// *
// *     The content of BSIM-CMG model (including source code,
// *  manual, technical note, and equation list) is currently 
// *  distributed by BSIM Group, a research group at EECS 
// *  Department, University of California at Berkeley, to 
// *  designated Receiving Parties only.
// *
// *     The content of BSIM-CMG model can not be distributed 
// *  by Receiving Party to any third party without written
// *  agreement by BSIM Group.
// *
// ********************************************************

// ********************************************************
// *  BSIM Common Multi-Gate Model (Verilog-A)
// *  SOICMG module, three terminal device (d, g, s)
// ********************************************************

`include "constants.vams"
`include "disciplines.vams"

`define ntype 1
`define ptype 0
`define q 1.6e-19
`define EPS0 8.8542e-12 	// units are F/m
`define HBAR 1.05457e-34	// untis are m2.kg/s
`define MEL 9.11e-31		// kg
`define EXP_THRESHOLD 80
`define MIN_EXP 1.804851387845e-35
`define KboQ 8.617087e-5


module soimg( d, g, s);
    inout d, g, s;
    electrical d, g, s;
    electrical di, si;
    branch (g, si) br_gsi;
    branch (di, si) br_disi;

    // parameters inside the model 
    
    parameter integer DEVTYPE= `ntype;
    parameter real LENGTH=25n from (0:inf);
    parameter real XL = 0;	     // L offset for channel length due to mask/etch effect
    parameter real DTL = 0;
    parameter real LINT = 0;	     // Length reduction parameter
    parameter real LL = 0;	     // Length reduction parameter
    parameter real LLN = 1;	     // Length reduction parameter
    parameter real LLC = 0;	     // Length reduction parameter
    parameter real DLC = 0;	     // Delta L for C-V model
    parameter real EOT=0.9n;         // effective gate dielectric thickness relative to SiO2, m 
    parameter real TFIN=25n;	     // units are m	
    parameter real HFIN=35n;         // fin height 
    parameter real FECH=1;           // end-channel factor, for different orientaion/shape
    parameter real DELTAW=0;         // reduction of effective width due to shape of fin
    parameter real FECHCV=1;         // CV end-channel factor, for different orientaion/shape
    parameter real DELTAWCV=0;       // CV reduction of effective width due to shape of fin
    
    parameter real NBODY=1e22;	     // units are m-3
    parameter real LNBODY=0;	
    parameter real PHIG=4.61;        // Gate workfunction, eV
    parameter real LPHIG=0;
    
    parameter real EPSROX = 3.9;     // Relative dielectric constant of the gate dielectric
    parameter real EPSRSUB=11.9;     // Relative dielectric constant of the channel material
    parameter real EASUB=4.05;       // Electron affinity of substrate, eV
    parameter real NI0SUB=1.45e16;   // Intrinsic carrier constant at 300.15K, m-3
    parameter real BG0SUB=1.16;      // Band gap of substrate at 300.15K, eV
    parameter real NC0SUB=2.86e25;   // Conduction band density of states, m-3
    parameter real NF = 10;          // number of device in parallel
    parameter integer IGMOD = 0;     // Gate current switcher; 0=turn off, 1=turn on
    parameter integer GIDLMOD = 1;   // GIDL/GISL switcher; 0=turn off, 1=turn on
    parameter integer PHISMOD = 0;   // Simplified Surface Potential Solution
    				     // 0=turn off, 1=turn on (lightly-doped or undoped)
    parameter integer GEOMOD = 1;    // structure slector
                                     // 0 = double gate, 1 = triple gate, 
                                     // 2 = quadruple gate
    
    // Short Channel Effects
    parameter real NSD=2e26;         // units are m-3
    parameter real LNSD=0;
    parameter real CIT=0.0;          // parameter for interface trap
    parameter real LCIT=0;
    parameter real CDSC=7e-3;        // coupling capacitance between S/D and channel
    parameter real LCDSC=0;
    parameter real CDSCD=7e-3;       // drain-bias sensitivity of CDSC
    parameter real LCDSCD=0;
    parameter real DVT2=1;	     // Subthreshold Slope decrease
    parameter real DVT0=0.0;         // SCE coefficient
    parameter real LDVT0=0;
    parameter real DVT1=0.60;        // SCE exponent coefficient
    parameter real LDVT1=0;
    parameter real PHIN=0.05;        // Nonuniform vertical doping effect on surface potential, V
    parameter real LPHIN=0;
    parameter real ETA0 = 0.60;      // DIBL coefficient
    parameter real LETA0=0;
    parameter real DSUB=1.06;        // DIBL exponent coefficient
    parameter real LDSUB=0;
    parameter real K1RSCE=0.000;     // K1 for reverse short channel effect calculation (due to pocket implant)
    parameter real LK1RSCE=0;
    parameter real LPE0=5.000n;      // Equivalent length of pocket region at zero bias
    parameter real LLPE0=0;
    
    // Quantum Mechanical Effect
    parameter real QMFACTOR = 0.0;   // prefactor for QM correction
    parameter real LQMFACTOR = 0;
    
    // Drain Saturation Voltage
    parameter real VSAT=85000;       // Saturation Velocity m/s
    parameter real LVSAT=0;
    parameter real KSATIV=1.3;       // parameter for long channel Vdsat
    parameter real LKSATIV=0;
    parameter real MEXP=4;           // Smoothing function factor for Vdsat
    parameter real LMEXP=0;
    
    // Mobility Degradation
    parameter integer MOBMOD = 0;    // Mobility Model switcher; 0=BSIM4, 1=PSP
    parameter real U0=300e-4;        // Shared: low-field mobility (m^2/V-s)
    parameter real LU0=0;
    parameter real LT=250e-9;
    parameter real ETAMOB=2.0;       // Effective field parameter
    parameter real UP=0;             // Shared: Mobility L coefficient
    parameter real LUP=0;            // Shared
    parameter real LP=5e-9;          // Shared: Mobility L exponent coefficient, m
    parameter real LLP=0;            // Shared
    parameter real MUE=1.2;          // MOD1: Mobility reduction coefficient
    parameter real LMUE=0;           // MOD1
    parameter real THETAMU=1.0;      // MOD1: Mobility reduction exponent
    parameter real CS=0;             // MOD1: Coulombic scattering parameter
    parameter real LCS=0;            // MOD1
    parameter real UA=0.3;           // MOD0: Mobility reduction coefficient
    parameter real LUA=0;            // MOD0
    parameter real EU=2.5;           // MOD0: Mobility reduction exponent
    parameter real LEU=0;            // MOD0
    parameter real UD=0;             // MOD0: Coulombic scattering parameter
    parameter real LUD=0;            // MOD0
    parameter real UCS=1.0;          // MOD0: Coulombic scattering parameter
    parameter real LUCS=0;           // MOD0
    
    // Polysilicon Depletion
    parameter real NGATE=0;          // parameter for Poly Gate Doping
                                     // NGATE=0 stands for metal gate
    parameter real LNGATE=0;
    
    // Channel Lenth Modulation
    parameter real ALP=0.013;        // CLM prefactor
    parameter real LALP=0;
    parameter real ALP1=0.0;         // CLM parameter in strong inversion
    parameter real LALP1=0;
    parameter real ALP2=0.0;         // CLM parameter in subthreshold
    parameter real LALP2=0;
    parameter real VP=0.05;          // CLM log dependence parameter
    
    // S/D Series Resistance
    parameter integer RDSMOD = 0;    // S/D resistance mod switch
                                     //   0: Internal 1: External
    parameter real RDSWMIN = 0.0;    // S/D extension resistance per unit width at high Vgs, ohm(um)^WR
    parameter real RDSW = 200.0;      // zero bias S/D extension  resistance per unit width, ohm(um)^WR
    parameter real LRDSW=0;
    parameter real RDWMIN = 0.0;     // Drain Resistance for RDSMOD=1
    parameter real RDW = 100.0;       // zero bias Drain Resistance for RDSMOD=1
    parameter real LRDW = 0.0;
    parameter real RSWMIN = 0.0;     // Source Resistance for RDSMOD=1
    parameter real RSW = 100.0;       // zero bias Source Resistance for RDSMOD=1
    parameter real LRSW = 0.0;
    parameter real PRWG = 0;         // gate bias dependence of S/D extension resistance, V-1
    parameter real LPRWG = 0;
    parameter real WR = 1.0;         // W dependence parameter of S/D extension resistance
    parameter real LWR = 0;
    
    // Velocity Saturation
    parameter real THETASAT=2.0;     // Velocity saturation parameter
    parameter real LTHETASAT=0;
    
    // Output Conductance due to DIBL
    parameter real PDIBL1=1.30;      // parameter for DIBL effect on Rout
    parameter real LPDIBL1=0;
    parameter real PDIBL2=0.0002;    // parameter for DIBL effect on Rout
    parameter real LPDIBL2=0;
    parameter real DROUT=1.06;       // L dependence of DIBL effect on Rout
    parameter real LDROUT=0;
    parameter real PVAG=1.0;         // Vg dependence on early voltage
    parameter real LPVAG=0;
    
    // Velocity Overshoot and Source end injection limit
    parameter real XJ=5e-8;          // S/D junction depth
    parameter real LXJ=0;
    parameter real LAMBDA=0.0;       // Velocity overshoot coef.
    parameter real LLAMBDA=0;
    
    // Gate Current
    parameter real AIGC=1.36e-2;     // parameter for Igc in inversion
    parameter real LAIGC=0;
    parameter real BIGC=1.71e-3;     // parameter for Igc in inversion
    parameter real LBIGC=0;
    parameter real CIGC=0.075;       // parameter for Igc in inversion
    parameter real LCIGC=0;
    parameter real NIGC=1.0;         // parameter for Igc in inversion
    parameter real LNIGC=0;
    parameter real DLCIG=0;          // Delta L for Igs model
    parameter real AIGS=1.36e-2;     // parameter for Igs in inversion
    parameter real LAIGS=0;
    parameter real BIGS=1.71e-3;     // parameter for Igs in inversion
    parameter real LBIGS=0;
    parameter real CIGS=0.075;       // parameter for Igs in inversion
    parameter real LCIGS=0;
    parameter real POXEDGE=1;        // Factor for the gate edge Tox
    parameter real LPOXEDGE=0;
    parameter real AGIDL=6.055p;     // pre-exponential coeff. for GIDL in mho
    parameter real LAGIDL=0;
    parameter real BGIDL=0.3e9;      // exponential coeff. for GIDL in V/m
    parameter real LBGIDL=0;
    parameter real EGIDL=0.2;        // band bending parameter for GIDL in V
    parameter real LEGIDL=0;
    
    // Impact Ionization Current
    parameter real ALPHA0=0.0;       // first parameter of Iii, m/V
    parameter real LALPHA0=0;
    parameter real ALPHA1=0.0;       // L scaling parameter of Iii, 1/V
    parameter real LALPHA1=0;
    parameter real BETA0=0.0;        // Vds dependent parameter of Iii, 1/V
    parameter real LBETA0=0;
    
    // Overlap Cap and Fringing Cap
    parameter real LOV=0.0;          // Overlap length for fg/s fg/d overlap (m)
    parameter real LLOV=0.0;
    parameter real CF=0.0;           // Outer Fringe Cap (F) 
    parameter real LCF=0.0;
    
    // Temperature Effects;
    parameter real TNOM=300.15;      // Temperature at which the model is 
                                     //   extracted (Kelvin)
    parameter real TBGASUB=7.02e-4;  // Bandgap Temperature Coefficient 
                                     //   (eV / degrees)
    parameter real TBGBSUB=1108.0;   // Bandgap Temperature Coefficient 
                                     //   (degrees)
    parameter real KT1=-0.3;         // Vth Temperature Coefficient (V)
    parameter real LKT1=0.0;
    parameter real KT1L=0.0;         // Vth Temperature L Coefficient (m-V)
    parameter real LKT1L=0.0;
    parameter real UTE=-1.4;         // Mobility Temperature Coefficient
    parameter real LUTE=0.0;
    parameter real UA1=-1.1;         // Mobility Temperature Coefficient
    parameter real LUA1=0.0;
    parameter real UD1=0.0;          // Mobility Temperature Coefficient
    parameter real LUD1=0.0;
    parameter real UCSTE=-4.775e-3;  // Mobility Temperature Coefficient
    parameter real LUCSTE=0.0;
    parameter real STTHETAMU = 1.5;  // Mobility Temperature Coefficient
    parameter real STMUE = 0.0;      // Mobility Temperature Coefficient
    parameter real STCS = 0.0;       // Mobility Temperature Coefficient
    parameter real AT = 0.005;       // Saturation Velocity Temperature
                                     //   Coefficient
    parameter real LAT = 0;
    parameter real STTHETASAT = 1.0; // Saturation Velocity Temperature
                                     //   Coefficient
    parameter real LSTTHETASAT = 0;
    parameter real PRT = 0.001;      // Resistance Temperature Dependence
    parameter real LPRT = 0;
    parameter real IIT = -0.5;       // Impact Ionization Temperature Dependence
    parameter real LIIT = 0;
    parameter real TGIDL = -0.0003;  // GIDL Temperature Dependence
    parameter real LTGIDL = 0;
    parameter real IGT = 2.5;        // Gate Current Temperature Dependence
    parameter real LIGT = 0;

    // variables inside the model
    (*retrieve*) real ids, vds, vgs, vgd;
    real vdsx, sigvds, vch;
    real qd, qfg, qs, qb, qbul;
    real ni, epsox, epssub, epsratio, Eg, Eg300, Nc;
    real Lnew, Leff, Leff2, LeffCV, Weff, WeffCV, cox, csi, cdsc;
    real nbody, phib, deltaPhi;
    real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TA, Ta, Tb, Tc;
    real exp_MAX, qfgqb_threshold;
    integer devsign;
    real Vtm, Vtm0, nVtm;

    // Temperature Effects
    real Tnom, TRatio, dvth_temp, UA_t, UCS_t, UD_t, U0_t;
    real MUE_t, THETAMU_t, CS_t, VSAT_t, THETASAT_t;
    real rdstemp, BETA0_t, BGIDL_t, igtemp;

    // ----- Variables for analytical surface potential -----
    real gamma0, r1, r2, ff, z1, z2, g0, tanb, cosb, cosbsq, secb, secbsq, lng0;
    real aaf0, aaf1, aarpirdr, aab; 
    real phis, phid, g0max, g0min;
    real T10, T11, T12, T13, T14;
    real expff, lnb, lncosb, br, e0, e1, e2, e3;
    
    // Accumulation Model
    real vgsfb, vgsfbeff;
    
    // FD Model
    real phibulk, phipert;
    
    // Short Channel Effect
    real scl, vbi, heff, phist, dvth_vtroll, dvth_dibl, dvth_rsce;
    
    // QM correction [units are MKS]
    real mx, coxe, E0qm;
    
    // Polysilicon Depletion
    real vpoly0, vpolym, plk, epsilon;
    
    // Drain Saturation Voltage
    real inv_MEXP, Vdsat, Vdseff;
    real qis, qbs, Eeffs, Esat, EsatL, Gmobs, Rdss, WVCox;
    
    // Midpoint Potential and Charge
    real phim, qim, qbm, dps;
    
    // Mobility Degradation
    real eta_mu, Eeffm, Gmob, u0, ueff;
    
    // Channel Lenth Modulation
    real r1clm, r2clm, dL, GdL, dL1, FdL;
    
    // S/D Series Resistance
    real Gr, rsource, rdrain;
    
    // Velocity Saturation
    real Gmob_r, Gmob_r_dL, thetasat1, zsat, Gvsat; 
    
    // Output Conductance
    real DIBLfactor, diffVds, VaDIBL;
    
    // Velocity Overshoot and Source end injection limit
    real litl, EsatovL;
    
    // Gate Current
    real Voxm;
    real Vauxs, Vauxd, igcs, igcd, igc; 
    real igisl, igidl, vfbsd, igs, igd, vgs_eff, vgd_eff;
    
    // Impact Ionization current
    real Iii;
    
    // Parasictic Capacitance
    real qgs_ov, qgd_ov, qgs_fr, qgd_fr, qgs_parasitic, qgd_parasitic;

    // Binning
    real Inv_L;
    real NBODY_i, PHIG_i, LOV_i, CF_i, XJ_i;
    real QMFACTOR_i, KSATIV_i;
    real NSD_i, CDSC_i, CDSCD_i, CIT_i, DVT0_i;
    real DVT1_i, PHIN_i, ETA0_i, DSUB_i, VSAT_i;
    real UP_i, LP_i, U0_i, NGATE_i, RDSW_i;
    real PRWG_i, WR_i, PDIBL1_i, PDIBL2_i;
    real DROUT_i, PVAG_i, LAMBDA_i;
    real AIGC_i, BIGC_i;
    real CIGC_i, NIGC_i, AIGS_i, BIGS_i, CIGS_i, POXEDGE_i;
    real AGIDL_i, BGIDL_i, EGIDL_i;
    real ALPHA0_i, ALPHA1_i, BETA0_i;
    real MEXP_i, MUE_i, CS_i;
    real ALP_i, ALP1_i, ALP2_i, THETASAT_i;
    real K1RSCE_i, LPE0_i;
    real UA_i, EU_i, UD_i, UCS_i, UA1_i, UD1_i, UCSTE_i, UTE_i;
    real THETAMU_i, STTHETASAT_i;
    real KT1_i, KT1L_i, AT_i;
    real RDSWMIN_i, RDWMIN_i, RSWMIN_i, RDW_i, RSW_i;
    real PRT_i, IIT_i, IGT_i, TGIDL_i;

    // analog block begins
    
    analog begin
        @(initial_step)
        begin
            // Effective Width Calculation
            Weff = 2 * HFIN +  FECH * TFIN - DELTAW;
            WeffCV = 2 * HFIN +  FECHCV * TFIN - DELTAWCV;
            if (GEOMOD == 0) begin
                Weff = 2 * HFIN - DELTAW;
                WeffCV = 2 * HFIN - DELTAWCV;
            end 
            if (GEOMOD == 2) begin 
                Weff = 2 * HFIN + 2 * FECH * TFIN - DELTAW;
                WeffCV = 2 * HFIN + 2 * FECHCV * TFIN - DELTAWCV;
            end        
            
            // Parameter Checking [Fatal]
	    if(EOT <= 0) begin
                $strobe("Fatal: eot = %e is not positive.", EOT);
            end
	    if(TFIN <= 0) begin
                $strobe("Fatal: TFIN = %e is not positive.", TFIN);
            end
	    if(HFIN <= 0) begin
                $strobe("Fatal: HFIN = %e is not positive.", HFIN);
            end

	    // Parameter Checking [Warning]
	    if(Weff <= 1e-9) begin
                $strobe("Warning: Weff = %e <= 1.0e-9.", Weff);
            end
	    if(WeffCV <= 1e-9) begin
                $strobe("Warning: WeffCV = %e <= 1.0e-9.", WeffCV);
            end
	    if(TFIN <= 1e-9) begin
                $strobe("Warning: TFIN = %e <= 1.0e-9.", TFIN);
            end
	    if(HFIN <= 1e-9) begin
                $strobe("Warning: HFIN = %e <= 1.0e-9.", HFIN);
            end
	    if(EOT <= 1e-10) begin
                $strobe("Warning: EOT = %e <= 1.0e-10.", EOT);
            end
	    THETAMU_i = THETAMU;
	    if(MOBMOD == 1 && THETAMU < 0) begin
                $strobe("Warning: THETAMU = %e is negative, setting it to 0.", THETAMU);
		THETAMU_i = 0;
            end

	    // Constants
            if( DEVTYPE == `ntype ) devsign = 1;
            else devsign = -1;
            exp_MAX = 30;
            epssub = EPSRSUB * `EPS0;
            epsox = EPSROX * `EPS0;        
            cox = 3.9 * `EPS0 / EOT;
            csi = epssub / TFIN;
            epsratio = EPSRSUB / 3.9; // for terms with EOT
            epsilon = 1e-5;
            qfgqb_threshold = 1e-10;

            // SCE scaling length
    	    scl = sqrt(0.5 * epsratio * TFIN * EOT * (1 + TFIN/(4*epsratio*EOT)));
            heff = sqrt(HFIN * (HFIN + 2 * epsratio * EOT) / 8);
    	    scl = 1 / sqrt(1 / (scl*scl) + 0.25 / (heff*heff));	
            if (GEOMOD == 0) scl = sqrt(0.5 * epsratio * TFIN * EOT * (1 + TFIN/(4*epsratio*EOT)));  
            if (GEOMOD == 2) scl = 0.5 * scl;
    
	    // Quantum Mechanical Effects
    	    mx = 0.916 * `MEL;


            // Effective Channel Length for I-V / C-V
            Lnew = LENGTH + XL;
            Leff = Lnew - 2 * (LINT + LL / pow(Lnew, LLN));  // BSIM4 maunal & code is inconsistent.  Follow code.
	    Leff2 = Lnew - DTL;
            LeffCV = Lnew - 2 * (DLC + LLC / pow(Lnew, LLN));  // BSIM4 maunal & code is inconsistent.  Follow code.
      
            // Binning
            Inv_L = 1e-6 / Leff;
            NBODY_i = NBODY + Inv_L * LNBODY;
            PHIG_i = PHIG + Inv_L * LPHIG;
            LOV_i = LOV + Inv_L * LLOV;
            CF_i = CF + Inv_L * LCF;
            XJ_i = XJ + Inv_L * LXJ;
            QMFACTOR_i = QMFACTOR + Inv_L * LQMFACTOR;
            KSATIV_i = KSATIV + Inv_L * LKSATIV;
            NSD_i = NSD + Inv_L * LNSD;
            CDSC_i = CDSC + Inv_L * LCDSC;
            CDSCD_i = CDSCD + Inv_L * LCDSCD;
            CIT_i = CIT + Inv_L * LCIT;
            DVT0_i = DVT0 + Inv_L * LDVT0;
            DVT1_i = DVT1 + Inv_L * LDVT1;
            PHIN_i = PHIN + Inv_L * LPHIN;
            ETA0_i = ETA0 + Inv_L * LETA0;
            DSUB_i = DSUB + Inv_L * LDSUB;
            K1RSCE_i = K1RSCE + Inv_L * LK1RSCE;
    	    LPE0_i = LPE0 + Inv_L * LLPE0;
            VSAT_i = VSAT + Inv_L * LVSAT;
            UP_i = UP + Inv_L * LUP;
            LP_i = LP + Inv_L * LLP;
            U0_i = U0 + Inv_L * LU0;
            NGATE_i = NGATE + Inv_L * LNGATE;
            RDSW_i = RDSW + Inv_L * LRDSW;
            RDW_i = RDW + Inv_L * LRDW;
            RSW_i = RSW + Inv_L * LRSW;
            PRWG_i = PRWG + Inv_L * LPRWG;
            WR_i = WR + Inv_L * LWR;
            THETASAT_i = THETASAT + Inv_L * LTHETASAT;
            PDIBL1_i = PDIBL1 + Inv_L * LPDIBL1;
            PDIBL2_i = PDIBL2 + Inv_L * LPDIBL2;
            DROUT_i = DROUT + Inv_L * LDROUT;
            PVAG_i = PVAG + Inv_L * LPVAG;
            LAMBDA_i = LAMBDA + Inv_L * LLAMBDA;
            AIGC_i = AIGC + Inv_L * LAIGC;
            BIGC_i = BIGC + Inv_L * LBIGC;
            CIGC_i = CIGC + Inv_L * LCIGC;
            NIGC_i = NIGC + Inv_L * LNIGC;
            AIGS_i = AIGS + Inv_L * LAIGS;
            BIGS_i = BIGS + Inv_L * LBIGS;
            CIGS_i = CIGS + Inv_L * LCIGS;
            POXEDGE_i = POXEDGE + Inv_L * LPOXEDGE;
            AGIDL_i = AGIDL + Inv_L * LAGIDL;
            BGIDL_i = BGIDL + Inv_L * LBGIDL;
            EGIDL_i = EGIDL + Inv_L * LEGIDL;
            ALPHA0_i = ALPHA0 + Inv_L * LALPHA0;
            ALPHA1_i = ALPHA1 + Inv_L * LALPHA1;
            BETA0_i = BETA0 + Inv_L * LBETA0;
            MEXP_i = MEXP + Inv_L * LMEXP;
            MUE_i = MUE + Inv_L * LMUE;
            CS_i = CS + Inv_L * LCS;
	    UA_i = UA + Inv_L * LUA;
	    EU_i = EU + Inv_L * LEU;
	    UD_i = UD + Inv_L * LUD;
	    UCS_i = UCS + Inv_L * LUCS;
            ALP_i = ALP + Inv_L * LALP;
            ALP1_i = ALP1 + Inv_L * LALP1;
            ALP2_i = ALP2 + Inv_L * LALP2;
	    KT1_i = KT1 + Inv_L * LKT1;
	    KT1L_i = KT1L + Inv_L * LKT1L;
	    UTE_i = UTE + Inv_L * LUTE;
	    UA1_i = UA1 + Inv_L * LUA1;
	    UD1_i = UD1 + Inv_L * LUD1;
	    UCSTE_i = UCSTE + Inv_L * LUCSTE;
	    AT_i = AT + Inv_L * LAT;
	    STTHETASAT_i = STTHETASAT + Inv_L * LSTTHETASAT;
	    PRT_i = PRT + Inv_L * LPRT;
	    IIT_i = IIT + Inv_L * LIIT;
	    TGIDL_i = TGIDL + Inv_L * LTGIDL;
	    IGT_i = IGT + Inv_L * LIGT;

	    // Parameter Checking [Fatal]
	    if(LPE0_i < -Leff) begin
                $strobe("Fatal: LPE0_i = %e is less than -Leff.", LPE0_i);
            end
	    if(NBODY_i <= 0) begin
	        $strobe("Fatal: NBODY_i = %e is not positive.", NBODY_i);
	    end
	    if(NGATE_i < 0) begin
	        $strobe("Fatal: NGATE_i = %e is negative.", NGATE_i);
	    end
	    if(NGATE_i > 1e31) begin
	        $strobe("Fatal: NGATE_i = %e is too high.", NGATE_i);
	    end
	    if(XJ_i <= 0) begin
	        $strobe("Fatal: XJ_i = %e is not positive.", XJ_i);
	    end
	    if(DVT1_i <= 0) begin
	        $strobe("Fatal: DVT1_i = %e is not positive.", DVT1_i);
	    end
	    if(DSUB_i <= 0) begin
	        $strobe("Fatal: DSUB_i = %e is not positive.", DSUB_i);
	    end
	    if(DROUT_i <= 0) begin
	        $strobe("Fatal: DROUT_i = %e is not positive.", DROUT_i);
	    end
	    if(NF < 1) begin
	        $strobe("Fatal: Number of finger = %e is smaller than one.", NF);
	    end
	    if(IGMOD != 0 && NIGC_i <= 0) begin
	        $strobe("Fatal: NIGC_i = %e is non-positive.", NIGC_i);
	    end
	    if(IGMOD != 0 && POXEDGE_i <= 0) begin
	        $strobe("Fatal: POXEDGE_i = %e is non-positive.", POXEDGE_i);
	    end

	    // Parameter Checking [Warning]
	    if(Leff <= 1e-9) begin
                $strobe("Warning: Leff = %e <= 1.0e-9.", Leff);
            end
	    if(LeffCV <= 1e-9) begin
                $strobe("Warning: LeffCV = %e <= 1.0e-9.", LeffCV);
            end
	    if(NBODY_i <= 1e18) begin
                $strobe("Warning: NBODY_i = %e may be too small.", NBODY_i);
            end
	    if(NBODY_i >= 1e27) begin
                $strobe("Warning: NBODY_i = %e may be too large.", NBODY_i);
            end
	    if(NGATE_i != 0 && NGATE_i <= 1e24) begin
                $strobe("Warning: NGATE_i = %e may be too small.", NGATE_i);
            end
	    if(MEXP_i < 2) begin
                $strobe("Warning: MEXP_i = %e < 2.  Setting MEXP_i = 2.", MEXP_i);
                MEXP_i = 2;
            end
	    if(DVT0_i < 0) begin
                $strobe("Warning: DVT0_i = %e is negative.", DVT0_i);
            end
	    if(CDSC_i < 0) begin
                $strobe("Warning: CDSC_i = %e is negative.", CDSC_i);
            end
	    if(CDSCD_i < 0) begin
                $strobe("Warning: CDSCD_i = %e is negative.", CDSCD_i);
            end
	    if(ETA0_i < 0) begin
                $strobe("Warning: ETA0_i = %e is negative.", ETA0_i);
            end
	    if(PRWG_i < 0) begin
                $strobe("Warning: PRWG_i = %e is negative.  Set to zero", PRWG_i);
                PRWG_i = 0;
            end
	    if(RDSW_i < 0) begin
                $strobe("Warning: RDSW_i = %e is negative.  Set to zero", RDSW_i);
                RDSW_i = 0;
            end
	    if(RDW_i < 0) begin
                $strobe("Warning: RDW_i = %e is negative.  Set to zero", RDW_i);
                RDW_i = 0;
            end
	    if(RSW_i < 0) begin
                $strobe("Warning: RSW_i = %e is negative.  Set to zero", RSW_i);
                RSW_i = 0;
            end
            RDSWMIN_i = RDSWMIN;
	    if(RDSWMIN_i < 0) begin
                $strobe("Warning: RDSWMIN = %e is negative.  Set to zero", RDSWMIN_i);
                RDSWMIN_i = 0;
            end
            RDWMIN_i = RDWMIN;
	    if(RDWMIN_i < 0) begin
                $strobe("Warning: RDWMIN = %e is negative.  Set to zero", RDWMIN_i);
                RDWMIN_i = 0;
            end
            RSWMIN_i = RSWMIN;
	    if(RSWMIN_i < 0) begin
                $strobe("Warning: RSWMIN = %e is negative.  Set to zero", RSWMIN_i);
                RSWMIN_i = 0;
            end
	    if(LAMBDA_i > 1e-9) begin
                $strobe("Warning: LAMBDA_i = %e may be too large.", LAMBDA_i);
                LAMBDA_i = 0;
            end
	    if(PDIBL1_i < 0) begin
                $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i);
            end
	    if(PDIBL2_i < 0) begin
                $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i);
            end
	    if(CF_i < 0) begin
                $strobe("Warning: CF_i = %e is negative.", CF_i);
            end
	    if(LOV_i < 0) begin
                $strobe("Warning: LOV_i = %e is negative.", LOV_i);
            end
	    if(MOBMOD == 0) begin
	        if(CS_i < 0) begin
                    $strobe("Warning: UA_i = %e is negative.", UA_i);
                end
	        if(UD_i < 0) begin
                    $strobe("Warning: UD_i = %e is negative.", UD_i);
                end
	        if(EU_i < 0) begin
                    $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
		    EU_i = 0;
                end
	        if(UCS_i < 0) begin
                    $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i);
		    UCS_i = 0;
                end
            end
	    if(MOBMOD == 1) begin
	        if(CS_i < 0) begin
                    $strobe("Warning: CS_i = %e is negative.", CS_i);
                end
	        if(MUE_i < 0) begin
                    $strobe("Warning: MUE_i = %e is negative.", MUE_i);
                end
            end

            // Temperature dependent constants
	    Tnom = TNOM;
	    TRatio = $temperature / Tnom;
            Vtm0 = `KboQ * Tnom;
            Vtm = `KboQ * $temperature;
	    Eg300 = BG0SUB - TBGASUB * (300.15) * (300.15) / (300.15 + TBGBSUB);
	    Eg = BG0SUB - TBGASUB * $temperature * $temperature / ($temperature + TBGBSUB);
            T1 = ($temperature / 300.15) * sqrt($temperature / 300.15);
            ni = NI0SUB * T1 * exp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
            Nc = NC0SUB * T1;

            // Temperature Effects Model
	    dvth_temp = (KT1_i + KT1L_i / Leff) * (TRatio - 1);
	    U0_t = U0_i * pow(TRatio, UTE_i);
	    UA_t = UA_i * pow(TRatio, UA1_i);
	    UD_t = UD_i * pow(TRatio, UD1_i);
	    UCS_t = UCS_i * pow(TRatio, UCSTE_i);
	    THETAMU_t = THETAMU_i * pow(1.0 / TRatio, STTHETAMU);
	    MUE_t = MUE_i * pow(1.0 / TRatio, STMUE);
	    CS_t = CS_i * pow(1.0 / TRatio, STCS);
	    THETASAT_t = THETASAT_i * pow(1.0 / TRatio, STTHETASAT_i);
	    VSAT_t = VSAT_i * (1 - AT_i * ($temperature - Tnom));
	    if(VSAT_t < 1000) begin
                $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", $temperature, VSAT_t);
	        VSAT_t = 1000;
	    end
	    rdstemp = (1 + PRT_i * ($temperature - Tnom));
	    BETA0_t = BETA0_i * pow(TRatio, IIT_i);
	    BGIDL_t = BGIDL_i * max(1 + TGIDL_i * ($temperature - Tnom), 0);
	    igtemp = pow(TRatio, IGT_i);

    	    if(PHISMOD != 0 && NBODY_i > 1e23) nbody = 1e23;  // Limit doping to 1e18 cm^-3 in the simplified analytical surface potential case
            else nbody = NBODY_i;

    	    phib = Vtm * ln(nbody/ni);
            vfbsd = devsign*(PHIG_i - (EASUB + Eg/2 - devsign * min(Eg/2, Vtm*ln(NSD_i/ni))));
    	    vbi = Vtm * ln(nbody*NSD_i/(ni*ni));


            // FD Model
            gamma0 = sqrt(2 * `q * nbody * epssub) / cox;
    	    phibulk = `q/(2*epssub) * nbody * (TFIN/2) * (TFIN/2);
            phipert = phibulk;
            qbul = (PHISMOD != 0) ? 0 : (sqrt(2* `q * nbody * epssub * phipert));

            // deltaPhi definition and Polysilicon Depletion
	    // deltaPhi: workfunction difference between the gate and the
	    // n+ source.
            if(NGATE_i > 0)
                deltaPhi = max(0, Eg/2 - Vtm*ln(NGATE_i/ni));
            else
                deltaPhi = devsign*(PHIG_i - (EASUB + (DEVTYPE == `ntype ? 0 : Eg)));
            vpoly0 = `q * NGATE_i * epssub / (2 * cox * cox);

            // Analytical Surface Potential
            r1 = 2.0*epssub/(cox*TFIN);
            if(NGATE_i>0)  r2 = 4.0*Vtm*epssub/(`q*TFIN*TFIN*NGATE_i);
            else         r2 = 0.0;
            g0max = 1.57079;   
            g0min = 1e-37;
            aarpirdr = 1.0 / (r1 * `M_PI);

            // Drain Saturation Voltage
            inv_MEXP = 1 / MEXP_i;

            // Mobility Degradation
    	    //u0 = U0_t * (1 - UP_i / (1 + exp((Leff - LT) / LP_i)));   
	    //u0 = U0_t * (1 - UP_i / (1 + pow(Leff / LP, LT)));   
	    u0 = U0_t * (1 - UP_i * pow( Leff, - LP ));    
    	    eta_mu = 0.5 * ETAMOB;
    	    if( DEVTYPE == `ptype ) begin
                eta_mu = 1.0 / 3 * ETAMOB;
            end

            // Output Conductance due to DIBL
            DIBLfactor = 0.5 * PDIBL1_i / (cosh(DROUT_i*Leff/scl + 1e-6) - 1) + PDIBL2_i;

        end      // end of initialization

        // *** Load Terminal Voltages ***

        vgs = devsign * V(g, si);
        vds  = devsign * V(di, si);
        vgd = devsign * V(g, di);


        // *** Source-drain interchange ***

        sigvds = 1.0;
        if  (vds < 0.0) begin
              sigvds = -1.0;
              vgs = vgs - vds;
              vds  = -1.0 * vds;  
              vgd = vgd - vds;
        end
        vgsfb = vgs - deltaPhi;
        
        
        // *** Vds smoothing ***

        vdsx = sqrt (vds * vds + 0.01) - 0.1; 
        
        
        // *** SCE, DIBL, SS degradation effects ***

        phist = 0.4 + phib + PHIN_i;
        T0 = CDSC_i + CDSCD_i * vdsx;
        T1 = 2*cox*csi/(2*csi + cox);
        T2 = cosh(DVT1_i * Leff2 / scl + 1e-6) - 1;
        //cdsc = 0.5 * T0 / T2;
	cdsc= 0.5 * T0 / ( cosh(DVT2 * Leff2 / scl + 1e-6) - 1);
        nVtm = Vtm * (1 + (CIT_i / TRatio + cdsc) / T1);
        dvth_vtroll = -0.5 * DVT0_i / T2 * (vbi - phist);
        dvth_dibl = -0.5 * ETA0_i / (cosh(DSUB_i*Leff2 /scl + 1e-6)-1) * vdsx;
        dvth_rsce = K1RSCE_i * (sqrt(1 + LPE0_i / Leff2) - 1) * sqrt(phist);
        vgsfb = vgsfb - dvth_vtroll - dvth_dibl - dvth_rsce - dvth_temp;
	//$strobe("Leff/scl=%f",Leff/scl);
	//$strobe("cdsc=%f, T0=%f",cdsc,T0);
	//$strobe("dvth_vtroll=%f,vbi-phist=%f",dvth_vtroll,vbi-phist); 
	//$strobe("dvth_dibl=%f,vdsx=%f",dvth_dibl,vdsx);
	//$strobe("dvth_rsce=%f,sqrt(phist)=%f",dvth_rsce,sqrt(phist));
        

        // *** Threshold voltage shift for doped multi-gate FET ***
        //     Necessary when PHISMOD = 1 (Simplified surface potential solution)

        if(PHISMOD != 0) begin
            vgsfb = vgsfb - 0.5 * `q * nbody * TFIN / cox;
        end
        
        
        // *** Vgs Clamping for accumulation region ***

        T0 = phib + Eg/2;
        T1 = vgsfb + phib + Eg/2;
        T2 = 1E-8;
        vgsfbeff = 0.5 *(T1 + sqrt(T1*T1 + 4*T2)) - T0;
        
        
        // *** Common Surface Potential calculations ***

        aaf0 = 0.5*ln(2*epssub*nVtm/(`q*Nc));
        aaf1 = aaf0 + ln(2.0/TFIN);
        aab = phibulk/(nVtm*nVtm);       
        
        // T1x are temporary variables needs to be used for both
        //    source and drain surface potential calculations.
        T14 = 2.0*nVtm;
        T10 = (vgsfbeff - phipert)/T14 - aaf1;
        T0 = phipert*aab;
        T11 = r1*sqrt(T0)+r2*T0;
        T12 = exp(phipert/(2.0*nVtm));
        T13 = T12*T12;
        

        // *** Surface Potential at the source end ***

        vch = 0.0;
        
        // Quantum Mechanical Correction
	// TODO: add doping dependence (still bias independent)
        T0 = `HBAR * `M_PI / TFIN;
        E0qm = T0 * T0 / (2 * mx);
        vch = vch + QMFACTOR_i * E0qm / `q;
        
        if(PHISMOD != 0) begin
        
            // Surface potential calculation for lightly-doped double gate MOSFET
            ff = (vgsfbeff - vch)/(2.0*nVtm) - aaf1;
            if (ff > exp_MAX)    ff = exp_MAX;
            expff = exp(ff);
        
            // Initial guess for sub-threshold
            z1 = atan(expff);
        
            // Initial guess for strong inversion
            if (ff > exp_MAX)    T0 = ff;
            else                 T0 = ln(1 + expff);
            z2 = atan(2*T0*aarpirdr);
        
            // initial guess
            g0 = min(z1, max(z2, 1e-15));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            lnb = ln(g0);
            secbsq = tanb*tanb + 1.0;
            lncosb = -0.5 * ln(secbsq);
            br = 1.0 / g0;
        
            T0 = g0 * tanb;
            T1 = T0 * T0;
        
            e0 = lnb - lncosb + r1*T0 + r2*T1 - ff;
            e1 = br + secbsq*g0*(r1 + 2.0*r2*T0) + tanb*(1.0 + (r1 + 2.0*r2*T0));
            e2 = secbsq*(1.0 + 2.0*(r1 + r2*g0*g0*secbsq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + br*br*(2.0*T1*r2 - 1.0);
            e3 = 2.0*br*br*br + 2.0*g0*secbsq*secbsq*(r1 + 2.0*r2*(3.0 + 4.0*T0)) 
               + 2.0*secbsq*tanb*(1.0 + 3.0*r1 + 2.0*r1*T0 +2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
        
            // 1st stage correction
            g0 = g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            lnb = ln(g0);
            secbsq = tanb*tanb + 1;
            lncosb = -0.5 * ln(secbsq);
            br = 1.0/g0;
        
            T0 = g0 * tanb;
            T1 = T0 * T0;
        
            e0 = lnb - lncosb + r1*T0 + r2*T1 - ff;
            e1 = br + secbsq*g0*(r1 + 2.0*r2*T0) + tanb*(1.0 + (r1 + 2.0*r2*T0));
            e2 = secbsq*(1.0 + 2.0*(r1 + r2*g0*g0*secbsq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + br*br*(2.0*T1*r2 - 1.0);
            e3 = 2.0*br*br*br + 2.0*g0*secbsq*secbsq*(r1 + 2.0*r2*(3.0 + 4.0*T0)) 
               + 2.0*secbsq*tanb*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
        
            // 2nd stage correction
            g0 = g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            // Calculate surface potential
            phis = vch + 2.0*nVtm*(ln(g0)-ln(cos(g0))+aaf1);
        
        end else begin
        
            // Surface potential calculation for heavily-doped double gate MOSFET
            ff = T10 - vch/T14;
        
            // Initial guess for sub-threshold
            z1 = atan(exp(ff-T11));
        
            // Initial guess for strong inversion
            if (ff > exp_MAX)     T0 = ff;
            else                  T0 = ln(1 + exp(ff));
            z2 = atan(2*T0*aarpirdr / T12);
        
            // initial guess
            g0 = min(z1, max(z2, 1e-15));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            cosb = cos(g0);
            cosbsq = cosb * cosb;
            secb = 1.0/cosb;
            secbsq = secb*secb;
            
            T0 = 1.0 + g0*tanb;
            T1 = g0*g0*(T13*secbsq-1.0) + aab*(phipert - T14*ln(cosb));
            T2 = sqrt(T1);
            T3 = -2.0*g0 + aab*T14*tanb + 2.0*T13*g0*secbsq*T0;
            T4 = -2.0 + 2.0*T13*g0*g0*secbsq*secbsq + 
            	secbsq*(2*T13 + aab*T14 + 8.0*T13*g0*tanb + 4.0*T13*g0*g0*tanb*tanb);
            T5 = 2.0*tanb*T4 + 4.0*(3.0*T13*g0*secbsq*secbsq*T0 + tanb + 2.0*T13*secbsq*T0*tanb);
                
            T7 = ln(g0) - ln(cosb) + r2*T1 + r1*T2 - ff;
            T8 = 1.0/g0 + tanb + r2*T3 + r1*T3/(2.0*T2);
            T9 = -1.0/(g0*g0) + secbsq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
            TA = 2.0/(g0*g0*g0) + 2.0*secbsq*tanb + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4)
            	+ r1*T5/(2.0*T2) + r2*T5;
            
            // 1st stage correction 
            g0 = g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));  
            if (g0 > g0max || g0 < g0min) begin
            	if(g0 > g0max)     g0 = g0max;
            	else               g0 = g0min;
            end
            
            tanb = tan(g0);
            cosb = cos(g0);
            cosbsq = cosb * cosb;
            secb = 1.0/cosb;
            secbsq = secb*secb;
            
            T0 = 1.0 + g0*tanb;
            T1 = g0*g0*(T13*secbsq-1.0) + aab*(phipert - T14*ln(cosb));
            T2 = sqrt(T1);
            T3 = -2.0*g0 + aab*T14*tanb + 2.0*T13*g0*secbsq*T0;
            T4 = -2.0 + 2.0*T13*g0*g0*secbsq*secbsq + 
            	secbsq*(2*T13 + aab*T14 + 8.0*T13*g0*tanb + 4.0*T13*g0*g0*tanb*tanb);
            T5 = 2.0*tanb*T4 + 4.0*(3.0*T13*g0*secbsq*secbsq*T0 + tanb + 2.0*T13*secbsq*T0*tanb);
               
            T7 = ln(g0) - ln(cosb) + r2*T1 + r1*T2 - ff;
            T8 = 1.0/g0 + tanb + r2*T3 + r1*T3/(2.0*T2);
            T9 = -1.0/(g0*g0) + secbsq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
            TA = 2.0/(g0*g0*g0) + 2.0*secbsq*tanb + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4)
            	+ r1*T5/(2.0*T2) + r2*T5;
            
            // 2nd stage correction 
            g0 = g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));  
            if (g0 > g0max || g0 < g0min) begin
            	if(g0 > g0max)     g0 = g0max;
            	else               g0 = g0min;
            end
            
            lng0 = ln(g0);
            phis = vch + T14*(lng0-ln(cos(g0))+aaf1) + phipert;
        
        end  // Surface Potential Model Switch
        
        
        // *** Drain Saturation Voltage ***
        
        qbs = `q * nbody * TFIN / (2 * cox);
        qis = (PHISMOD != 0) ? (vgsfbeff - phis) : (vgsfbeff - phis - qbs);   // for consistency
        Eeffs = 1e-8 / epsratio / EOT * (qbs + eta_mu * qis); // in the unit of MV/cm
	if(MOBMOD == 0) begin
            T2 = 0.5 * pow(1 + abs(qis / (1.5 * Vtm)), UCS_t);
            T3 = UA_t * pow(abs(Eeffs), EU) + UD_t / T2; 
            Gmobs = 1.0 + T3;
	end else begin
            T2 = (qbs/(qis+qbs)) *  (qbs/(qis+qbs));
            T3 = pow(abs(Eeffs * MUE_t), THETAMU_t) + CS_t * T2; 
            Gmobs = 1.0 + T3;
        end
        T4 = pow(Weff*1e6, WR_i); 
	if(RDSMOD == 0) begin
            Rdss = rdstemp * (RDSWMIN_i + RDSW_i / (1 + PRWG_i * qis)) / T4;  
        end else begin
	    Rdss = 0.0;
        end
        Esat = 2 * VSAT_t / u0 * Gmobs;
        EsatL = Esat * Leff;
        T5 = vgsfbeff-phis ;
        T6 = KSATIV_i * (T5 + 2*Vtm);
        
        if (Rdss == 0) begin
            Vdsat = EsatL * T6 / (EsatL + T6); 
        end else begin
            WVCox = Weff * VSAT_t * cox;
            T0 = WVCox * Rdss;
            Ta = 2 * T0;
            Tb = T6 + EsatL + 3*T6*T0;
            Tc = T6 * (EsatL + 2*T6*T0);
            Vdsat = (Tb - sqrt(Tb*Tb - 2*Ta*Tc)) / Ta;
        end
        
        T7 = pow(vds/max(Vdsat, 1e-6), MEXP_i);
        T8 = pow(1.0+T7, inv_MEXP);
        Vdseff = vds / T8; 
        
        
        // *** Surface Potential at the drain end ***
        
        vch = Vdseff;
        
        // Quantum Mechanical Correction
	// TODO: add doping dependence (still bias independent)
        T0 = `HBAR * `M_PI / TFIN;
        E0qm = T0 * T0 / (2 * mx);
        vch = vch + QMFACTOR_i * E0qm / `q;
        
        if(PHISMOD != 0) begin
        
            // Surface potential calculation for lightly-doped double gate MOSFET
            ff = (vgsfbeff - vch)/(2.0*nVtm) - aaf1;
            if (ff > exp_MAX)    ff = exp_MAX;
            expff = exp(ff);
        
            // Initial guess for sub-threshold
            z1 = atan(expff);
        
            // Initial guess for strong inversion
            if (ff > exp_MAX)    T0 = ff;
            else                 T0 = ln(1 + expff);
            z2 = atan(2*T0*aarpirdr);
        
            // initial guess
            g0 = min(z1, max(z2, 1e-15));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            lnb = ln(g0);
            secbsq = tanb*tanb + 1.0;
            lncosb = ln(cos(g0));
            br = 1.0 / g0;
            
            T0 = g0 * tanb;
            T1 = T0 * T0;
        
            e0 = lnb - lncosb + r1*T0 + r2*T1 - ff;
            e1 = br + secbsq*g0*(r1 + 2.0*r2*T0) + tanb*(1.0 + (r1 + 2.0*r2*T0));
            e2 = secbsq*(1.0 + 2.0*(r1 + r2*g0*g0*secbsq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + br*br*(2.0*T1*r2 - 1.0);
            e3 = 2.0*br*br*br + 2.0*g0*secbsq*secbsq*(r1 + 2.0*r2*(3.0 + 4.0*T0)) 
               + 2.0*secbsq*tanb*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
        
            // 1st stage correction
            g0 = g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            lnb = ln(g0);
            secbsq = tanb*tanb + 1;
            lncosb = -0.5 * ln(secbsq);
            br = 1.0/g0;
            
            T0 = g0 * tanb;
            T1 = T0 * T0;
        
            e0 = lnb - lncosb + r1*T0 + r2*T1 - ff;
            e1 = br + secbsq*g0*(r1 + 2.0*r2*T0) + tanb*(1.0 + (r1 + 2.0*r2*T0));
            e2 = secbsq*(1.0 + 2.0*(r1 + r2*g0*g0*secbsq + T0*r1 + 2.0*r2*(T1 + 2.0*T0))) + br*br*(2.0*T1*r2 - 1.0);
            e3 = 2.0*br*br*br + 2.0*g0*secbsq*secbsq*(r1 + 2.0*r2*(3.0 + 4.0*T0)) 
               + 2.0*secbsq*tanb*(1.0 + 3.0*r1 + 2.0*r1*T0 + 2.0*r2*(3.0*(1 + 2.0*T0) + 2.0*T1));
        
            // 2nd stage correction
            g0 = g0 - e0/e1*(1.0 + e0*e2/(2.0*e1*e1) + e0*e0*(3.0*e2*e2-e1*e3)/(6.0*e1*e1*e1*e1));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            // Calculate surface potential
            phid = vch + 2.0*nVtm*(ln(g0)-ln(cos(g0))+aaf1);
        
        end else begin
        
            // Surface potential calculation for heavily-doped double gate MOSFET
            ff = T10 - vch/T14;
        
            // Initial guess for sub-threshold
            z1 = atan(exp(ff-T11));
        
            // Initial guess for strong inversion
            if (ff > exp_MAX)     T0 = ff;
            else                  T0 = ln(1 + exp(ff));
            z2 = atan(2*T0*aarpirdr / T12);
        
            // initial guess
            g0 = min(z1, max(z2, 1e-15));
            if (g0 > g0max || g0 < g0min) begin
        	if(g0 > g0max)     g0 = g0max;
        	else               g0 = g0min;
            end
        
            tanb = tan(g0);
            cosb = cos(g0);
            cosbsq = cosb * cosb;
            secb = 1.0/cosb;
            secbsq = secb*secb;
            
            T0 = 1.0 + g0*tanb;
            T1 = g0*g0*(T13*secbsq-1.0) + aab*(phipert - T14*ln(cosb));
            T2 = sqrt(T1);
            T3 = -2.0*g0 + aab*T14*tanb + 2.0*T13*g0*secbsq*T0;
            T4 = -2.0 + 2.0*T13*g0*g0*secbsq*secbsq + 
            	secbsq*(2*T13 + aab*T14 + 8.0*T13*g0*tanb + 4.0*T13*g0*g0*tanb*tanb);
            T5 = 2.0*tanb*T4 + 4.0*(3.0*T13*g0*secbsq*secbsq*T0 + tanb + 2.0*T13*secbsq*T0*tanb);
              
            T7 = ln(g0) - ln(cosb) + r2*T1 + r1*T2 - ff;
            T8 = 1.0/g0 + tanb + r2*T3 + r1*T3/(2.0*T2);
            T9 = -1.0/(g0*g0) + secbsq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
            TA = 2.0/(g0*g0*g0) + 2.0*secbsq*tanb + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4)
            	+ r1*T5/(2.0*T2) + r2*T5;
            
            // 1st stage correction 
            g0 = g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));  
            if (g0 > g0max || g0 < g0min) begin
            	if(g0 > g0max)     g0 = g0max;
            	else               g0 = g0min;
            end
            
            tanb = tan(g0);
            cosb = cos(g0);
            cosbsq = cosb * cosb;
            secb = 1.0/cosb;
            secbsq = secb*secb;
            
            T0 = 1.0 + g0*tanb;
            T1 = g0*g0*(T13*secbsq-1.0) + aab*(phipert - T14*ln(cosb));
            T2 = sqrt(T1);
            T3 = -2.0*g0 + aab*T14*tanb + 2.0*T13*g0*secbsq*T0;
            T4 = -2.0 + 2.0*T13*g0*g0*secbsq*secbsq + 
            	secbsq*(2*T13 + aab*T14 + 8.0*T13*g0*tanb + 4.0*T13*g0*g0*tanb*tanb);
            T5 = 2.0*tanb*T4 + 4.0*(3.0*T13*g0*secbsq*secbsq*T0 + tanb + 2.0*T13*secbsq*T0*tanb);
               
            T7 = ln(g0) - ln(cosb) + r2*T1 + r1*T2 - ff;
            T8 = 1.0/g0 + tanb + r2*T3 + r1*T3/(2.0*T2);
            T9 = -1.0/(g0*g0) + secbsq - r1*T3*T3/(4*T2*T2*T2) + r1*T4/(2.0*T2) + r2*T4;
            TA = 2.0/(g0*g0*g0) + 2.0*secbsq*tanb + 3.0*r1*T3/(4.0*pow(T2,3))*(T3*T3/(2.0*T2*T2)-T4)
            	+ r1*T5/(2.0*T2) + r2*T5;
            
            // 2nd stage correction 
            g0 = g0 - T7/T8*(1.0 + T7*T9/(2.0*T8*T8) + T7*T7*(3.0*T9*T9-T8*TA)/(6.0*pow(T8,4)));  
            if (g0 > g0max || g0 < g0min) begin
            	if(g0 > g0max)     g0 = g0max;
            	else               g0 = g0min;
            end
            
            lng0 = ln(g0);
            phid = vch + T14*(lng0-ln(cos(g0))+aaf1) + phipert;
        
        end  // Surface Potential Model Switch
        
        
        // *** Polysilicon Depletion ***

        plk = 0;
        vpolym = 0;
        if(NGATE_i > 0) begin
            phim = 0.5 * (phis + phid);
            T0 = 1 / vpoly0;
            T1 = (vgsfbeff - phim) * T0;
            T2 = T1*T1 + 4 * epsilon;
            T3 = 0.5 * (T1 + sqrt(T2));
            T4 = sqrt(T3 + 1) - 1;
            plk = (-T4) / 2 / sqrt(T3+1) * (1 + T1 / sqrt(T2));   // dVpoly_dphi at phi=phim
            vpolym = vpoly0 * T4 * T4;
        end
        
        
        // *** Midpoint Potential and Charge ***
        
        phim = (phis + phid) / 2;
        qbm =  sqrt(phibulk) * gamma0;
        qim = (PHISMOD != 0) ? (vgsfbeff - phim - vpolym) : (vgsfbeff - phim - qbm - vpolym);  // for consistency
        dps = phid - phis;
        
        
        // *** Mobility Degradation ***

        Eeffm = 1e-8 / epsratio / EOT * (qbm + eta_mu * qim); // in the unit of MV/cm
        
	//Eeffm = 1e-8 / epsratio / EOT * (qbs + eta_mu * qis);
	
	if(MOBMOD == 0) begin
            T2 = 0.5 * pow(1 + abs(qim / (1.5 * Vtm)), UCS_t);
            T3 = UA_t * pow(abs(Eeffm), EU) + UD_t / T2; 
            Gmob = 1.0 + T3;
        end else begin
            T2 = (qbm/(qim+qbm)) *  (qbm/(qim+qbm));
            T3 = pow(abs(Eeffm * MUE_t), THETAMU_t) + CS_t * T2; 
            Gmob = 1.0 + T3;
        end

        ueff = u0 / Gmob;
	$strobe("ueff=%f @ vgs= %f",ueff,vgs);
        
        
        // *** Channel Length Modulation ***

        r1clm = qim / (qim + Vtm);
        r2clm = Vtm / (qim + 1e-10);
        T1 = ln((1.0 + (vds -dps) / VP) / (1.0 + (Vdseff - dps) / VP));
        T2 = ln(1.0 + vdsx / VP);
        dL = ALP_i * T1;
        GdL = 1.0 /(1.0 + dL + dL * dL);
        
        dL1 = dL + ALP1_i * r1clm * T1 / (qim + Vtm) + ALP2_i * qbm * r2clm * r2clm * T2;
        FdL = (1.0 + dL1 + dL1 * dL1) * GdL;
        
        
        // *** S/D series resistance ***
        
        T1 = pow(Weff*1e6, WR_i); 
	if(RDSMOD == 0) begin
	    // 2008.10.16 testing u0 gives better result than ueff in the following line
            T2 = u0 * cox * Weff / Leff * qim;
            Gr =  T2 * rdstemp * (RDSWMIN_i + RDSW_i / (1 + PRWG_i * qim)) / T1;  
        end else begin
	    Gr = 0.0;

	    // Rs (all fingers total)
	    T2 = vgs - vfbsd;
	    T3 = sqrt(T2 * T2 + 1.0e-4);
	    vgs_eff = 0.5 * (T2 + T3);
	    T4 = 1.0 + PRWG_i * vgs_eff;
	    T5 = 1.0 / T4;
	    T6 = 0.5 * (T5 + sqrt(T5 * T5 + 0.01));
	    rsource = rdstemp * (RSWMIN_i + RSW_i * T6) / T1 / NF;  

	    // Rd (all fingers total)
	    T2 = vgd - vfbsd;
	    T3 = sqrt(T2 * T2 + 1.0e-4);
	    vgd_eff = 0.5 * (T2 + T3);
	    T4 = 1.0 + PRWG_i * vgd_eff;
	    T5 = 1.0 / T4;
	    T6 = 0.5 * (T5 + sqrt(T5 * T5 + 0.01));
	    rdrain = rdstemp * (RDWMIN_i + RDW_i * T6) / T1 / NF;
	end
        
        // *** Velocity Saturation ***
        
        Gmob_r = Gmob + Gr;
        Gmob_r_dL = Gmob_r * GdL;
        thetasat1 = THETASAT_t / Gmob_r_dL;
        zsat = thetasat1 * thetasat1 * dps * dps;
        if( DEVTYPE == `ptype ) begin
            zsat = zsat / (1.0 + thetasat1 * dps);
        end
        Gvsat = 0.5 * Gmob_r_dL * (1.0 + sqrt(1.0 + 2.0 * zsat));
       //$strobe("Gmob= %3.3f, Gr = %3.3f, Gmobs= %3.3f zsat= %3.3f", Gmob, Gr, Gmobs,zsat);
        
        // *** IV Model ***
        
        qs = cox*(vgsfbeff - phis);
        qd = cox*(vgsfbeff - phid);
        T0 = 5.0 * Vtm * (epssub/TFIN);
        T1 = (T0 + qbul) * (ln(qs + T0)-ln(qd + T0));
        T2 = 2.0*Vtm - qbul/cox;
        T3 = cox*(vgsfbeff-vpolym-phim)*dps;
        ids =  u0 * Weff / Leff * (T3 + T2*(qs - qd) - Vtm*T1)*FdL/Gvsat;

        // *** Output Conductance Model ***
        
        if (Vdseff > vds) Vdseff = vds;
        diffVds = vds - Vdseff;
        if (DIBLfactor > 0) begin
            T1 = qim + 2 * Vtm;
            T3 = T1 / (Vdsat + T1);
            T4 = 1 + PVAG_i * T1 / EsatL;
            VaDIBL = T1 / DIBLfactor * T3 * T4;
            ids = ids * (1 + diffVds / VaDIBL);
        end


        // *** Velocity Overshoot ***
        
        litl = sqrt(epsratio * EOT * XJ_i);
        T1 = Leff * ueff; 
        T2 = LAMBDA_i / T1;
        T3 = Esat * litl;
        T4 = 1 + diffVds / T3;
        T5 = 2 / (T4 * T4 + 1);
        T6 = 1 - T5;
        T7 = 1 + T2 * T6;
        EsatovL = Esat * T7 * Leff;
        ids = ids * (1 + Vdseff/EsatL) / (1 + Vdseff/EsatovL);
        

        // *** CV Model *** 
        
        qb = qbul/cox;
        T0 = (1+plk)*dps;
        T1 = 2 * ( vgsfbeff - qb - vpolym + 2.0*Vtm);
        T2 = T1-phis-phid;
        qfg = vgsfbeff - vpolym - phim + T0*T0/(6*T2);
        T3 = -plk * dps / 12;
        T4 = T0 * T0 / (12 * T2);
        T5 = T0 * T0 * T0 / (60 * T2*T2);
        qd = 0.5 * (vgsfbeff - vpolym - qb) - (phis+phid+phid)/6 + T3 + T4 + T5;
        
        
        // *** Toxeff model for quantum mechanical effects ***
        
        if(qfg - qb < -qfgqb_threshold)
        begin
            qb = qfg;
        end
        
        T3 = cox*(qfg - qb) + 0.00001;    // T3 = Qi (coul / m / m)
        T4 = pow(10.5 * epssub * `HBAR * `HBAR / (mx * `q * T3), 0.333333333333);
        T5 = T4 / (TFIN/3);
        T6 = pow(T5, MEXP_i);
        T7 = pow(1+T6, inv_MEXP);
        T8 = T4 / T7;
        coxe = 3.9 * `EPS0 / (EOT + T8 / epsratio);
        
        
        // *** add sign to nodal charge***
        
        qd = -qd;
        qb = -qb;
        qs = -qfg - qd -qb;
        
        // if vds is negative, physical charge on d is qs
        if (sigvds < 0) begin
            T1 = qd;
            qd = qs; 	
            qs = T1;
        end
        
        
        // *** Multiply Normalized capacitances by gate area ***
        
        T1 = coxe * WeffCV * LeffCV;
        qfg = qfg * T1;
        qd = qd * T1;
        qb = qb * T1;
        qs = qs * T1;
        
        
        // *** Parasitic Capcitances ***
        
        T1 = WeffCV * LOV_i * cox;
        qgs_ov = T1 * vgs;
        qgd_ov = T1 * vgd;
        T2 = WeffCV * CF_i;
        qgs_fr = T2 * vgs;
        qgd_fr = T2 * vgd;
        qgs_parasitic = qgs_ov + qgs_fr;
        qgd_parasitic = qgd_ov + qgd_fr;
        
        if (sigvds < 0) begin
            T1 = qgd_parasitic;
            qgd_parasitic = qgs_parasitic;
            qgs_parasitic = T1;
        end
        
        
        // *** Impact Ionization Current ***

        T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;
        if ((T0 <= 0.0) || (BETA0_t <= 0.0))
           Iii = 0.0;
        else if (diffVds > BETA0_t / `EXP_THRESHOLD) begin
           T1 = - BETA0_t / diffVds;
           Iii = T0 * diffVds * ids * exp(T1);
        end else begin
           Iii = T0 * diffVds * ids * `MIN_EXP;
        end 
          

        // *** Gate Current ***
        
        igc       = 0.0;
        igcs      = 0.0; 
        igcd      = 0.0; 
        igs       = 0.0;
        igd       = 0.0;
        
        if (IGMOD != 0) begin
        
	    // Vox
            Voxm = vgsfbeff - phim;

            // Igcinv
            //T1 = (vgsfbeff - phis - qbul/cox) / NIGC_i / Vtm;
            //Vauxs = NIGC_i * Vtm * ln(1 + exp(T1));
            //T1 = (vgsfbeff - phid - qbul/cox) / NIGC_i / Vtm;
            //Vauxd = NIGC_i * Vtm * ln(1 + exp(T1));
            Vauxs = NIGC_i * (vgsfbeff - phis - qbul/cox);
            Vauxd = NIGC_i * (vgsfbeff - phid - qbul/cox);
            T1 = AIGC_i - BIGC_i * Voxm;
            T2 = 1 + CIGC_i * Voxm;
            if(DEVTYPE == `ntype)   T3 = 7.45669e11;
            else                    T3 = 1.16645e12;
            T4 = -T3 * T7 * T1 * T2;
            T5 = exp(T4);
            if(DEVTYPE == `ntype)   T6 = 4.97232e-7;
            else                    T6 = 3.42537e-7;
            T8 = Weff * Leff * T6 / T7 / T7;
            igcs = T8 * Voxm * Vauxs * T5;
            igcd = T8 * Voxm * Vauxd * T5;	
	    igcs = igcs * igtemp;
	    igcd = igcd * igtemp;
            igc = igcs + igcd;
          
            // Igs, Igd
            T0 = vgs - vfbsd;
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);
            T1 = AIGS_i - BIGS_i * vgs_eff;
            T2 = 1 + CIGS_i * vgs_eff;
            if(DEVTYPE == `ntype)   T3 = 7.45669e11;
            else                    T3 = 1.16645e12;
            T7 = EOT * EPSROX / 3.9;
            T4 = -T3 * T7 * POXEDGE_i * T1 * T2;
            T5 = exp(T4);
            if(DEVTYPE == `ntype)   T6 = 4.97232e-7;
            else                    T6 = 3.42537e-7;
            T7 = EOT * EPSROX / 3.9 * POXEDGE_i;
            T8 = Weff * DLCIG * T6 / T7 / T7; 
            igs = T8 * vgs * vgs_eff * T5;
	    igs = igs * igtemp;
          
            T0 = vgd - vfbsd;
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);
            T1 = AIGS_i - BIGS_i * vgd_eff;
            T2 = 1 + CIGS_i * vgd_eff;
            T7 = EOT * EPSROX / 3.9;
            T4 = -T3 * T7 * POXEDGE_i * T1 * T2;
            T5 = exp(T4);
            T7 = EOT * EPSROX / 3.9 * POXEDGE_i;
            T8 = Weff * DLCIG * T6 / T7 / T7; 
            igd = T8 * vgd * vgd_eff * T5;
	    igd = igd * igtemp;
        end
        
        
        // *** GIDL/GISL current ***

        igisl     = 0.0;
        igidl     = 0.0;
        
        if (GIDLMOD != 0) begin
           
           // GIDL
           T0 = epsratio * EOT;
           T1 = (vds - vgs - EGIDL_i + vfbsd) / T0;
           if ((T1 <= 0.0) || (AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
               igidl = 0.0;
           end else begin 
                 T2 = BGIDL_t / T1;
                 if (T2 < 100.0) begin
                 igidl = AGIDL_i * Weff * T1 * exp(-T2);
                 end else begin
                 igidl = AGIDL_i * Weff * 3.720075976e-44;
                 end
           end
        
           // GISL
           T0 = epsratio * EOT;
           T1 = (-vds - vgd - EGIDL_i + vfbsd) / T0;
           if ((T1 <= 0.0) || (AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
               igisl = 0.0;
           end else begin 
                 T2 = BGIDL_t / T1;
                 if (T2 < 100.0) begin
                 igisl = AGIDL_i * Weff * T1 * exp(-T2);
                 end else begin
         	 igisl = AGIDL_i * Weff * 3.720075976e-44;
                 end
           end
        
        end
        
        
        // *** Loading variables ***
        
        ids      = NF * ids;
        igidl    = NF * igidl;
        igisl    = NF * igisl;
        igc      = NF * igc;
        igcd     = NF * igcd;
        igcs     = NF * igcs;
        igs      = NF * igs;
        igd      = NF * igd;
        
        if (sigvds > 0) begin
            I(di, si)  <+ devsign * ids;
            I(di, si)  <+ devsign * (igidl + Iii);
            I(si, di)  <+ devsign * igisl; 
            I(g, si)  <+ devsign * (igcs + igs);
            I(g, di)  <+ devsign * (igcd + igd);
        end else begin
            I(si, di)  <+ devsign * ids;
            I(si, di)  <+ devsign * (igidl + Iii);
            I(di, si)  <+ devsign * igisl;
            I(g, di)  <+ devsign * (igcs + igs);
            I(g, si)  <+ devsign * (igcd + igd);
        end
        
        qd             = NF * qd;  
        qfg            = NF * qfg;
        qgs_parasitic  = NF * qgs_parasitic;
        qgd_parasitic  = NF * qgd_parasitic;
        
        I(di, si) <+ devsign * ddt(qd);
        I(g, si) <+ devsign * ddt(qfg);
        I(g, si) <+ devsign * ddt(qgs_parasitic);
        I(g, di) <+ devsign * ddt(qgd_parasitic);

	// External S/D Resistance
	if(RDSMOD == 0)
	begin
	    V(d, di) <+ 0;
	    V(s, si) <+ 0;
	end else begin
	    I(d, di) <+ V(d, di) / rdrain;
	    I(s, si) <+ V(s, si) / rsource;
	end
        
    end
endmodule

